// Effect Syntax Guide: https://docs.cocos.com/creator/manual/zh/shader/index.html

CCEffect %{
  techniques:
  - name: opaque
    passes:
    - vert: spectrum-vs:vert
      # frag: spectrum-fs:frag
      frag: spectrum-fs:frag
      properties: &props
        mainTexture:    { value: white }
        mainColor:      { value: [1, 1, 1, 1], editor: { type: color } }
        dist:           { value: 1000.0, editor: { slide: true, range: [0, 10000], step: 0.000001} }
        roughness:      { value: 0.2, editor: { slide: true, range: [0, 1], step: 0.0001} }
  - name: transparent
    passes:
    - vert: spectrum-vs:vert  
      frag: spectrum-fs:frag
      blendState:
        targets:
        - blend: true
          blendSrc: src_alpha
          blendDst: one_minus_src_alpha
          blendSrcAlpha: src_alpha
          blendDstAlpha: one_minus_src_alpha
      properties: *props
}%


CCProgram zucconi6 %{
  // --- Spectral Zucconi --------------------------------------------
  // By Alan Zucconi
  // Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html
  // But with values optimised to match as close as possible the visible spectrum
  // Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg
  // With weighter MSE (RGB weights: 0.3, 0.59, 0.11)
  vec3 bump3y (vec3 x, vec3 yoffset)
  {
    vec3 y = vec3(1.,1.,1.) - x * x;
    y = clamp(y-yoffset, 0.0, 1.0);
    return y;
  }
  vec3 spectral_zucconi (float w)
  {
      // w: [400, 700]
    // x: [0,   1]
    float x = clamp((w - 400.0)/ 300.0, 0.0, 1.0);

    const vec3 cs = vec3(3.54541723, 2.86670055, 2.29421995);
    const vec3 xs = vec3(0.69548916, 0.49416934, 0.28269708);
    const vec3 ys = vec3(0.02320775, 0.15936245, 0.53520021);

    return bump3y (	cs * (x - xs), ys);
  }

  // --- Spectral Zucconi 6 --------------------------------------------

  // Based on GPU Gems
  // Optimised by Alan Zucconi
  vec3 spectral_zucconi6 (float w)
  {
    // w: [400, 700]
    // x: [0,   1]
    float x = clamp((w - 400.0)/ 300.0, 0.0, 1.0);

    const vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);
    const vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);
    const vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);

    const vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);
    const vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);
    const vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);

    return
      bump3y(c1 * (x - x1), y1) +
      bump3y(c2 * (x - x2), y2) ;
  }
}%

CCProgram jet %{
      /**
    jet color spectral scheme
    @param  w : waveLength
    */
    vec3 spectral_jet(float w){

        float x = clamp((w - 400.0)/300.0, 0.0, 1.0);
        vec3 color = vec3(0.0);

        if(x < 0.25){
           color = vec3( 0.0, 4.0 * x, 1.0);
        }else if( x < 0.5){
            color = vec3(0.0, 1.0, 1.0 + 4.0 * (0.25 - x));
        }else if( x < 0.75){
           color = vec3( 4.0 * ( x - 0.5), 1.0, 0.0 );           
        }else {
          color = vec3( 1.0, 1.0 + 4.0 * (0.75 - x ), 0.0 );
        }
        color = clamp(color, 0.0, 1.0);
        return color;
    } 
}%

CCProgram spectrum-lib %{
    precision highp float;
    // https://www.shadertoy.cew/ls2Bz1

    #include "zucconi6"
    #include "jet" 
}%

CCProgram spectrum-vs %{
  
  precision highp float;
  #include <legacy/input-standard>
  #include <builtin/uniforms/cc-global>
  #include <legacy/local-batch>
  #include <legacy/input-standard>
  #include <legacy/fog-vs>
  #include <legacy/shadow-map-vs>
  #include "spectrum-lib"

  in vec4 a_color;
  #if HAS_SECOND_UV
    in vec2 a_texCoord1;
  #endif

  out vec3 v_position;
  out vec3 v_normal;
  out vec3 v_tangent;
  out vec3 v_bitangent;
  out vec2 v_uv;
  out vec2 v_uv1;
  out vec4 v_color;
  out vec3 v_rgb;

  uniform Constant {
    vec4 mainColor;
    float dist;
    float roughness;
  };

  vec4 vert () {
    StandardVertInput In;
    CCVertInput(In);

    mat4 matWorld, matWorldIT;
    CCGetWorldMatrixFull(matWorld, matWorldIT);

    vec4 pos = matWorld * In.position;

    v_position = pos.xyz;
    v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);
    v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);
    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w; // note the cross order    

    v_uv = a_texCoord;
    #if HAS_SECOND_UV
      v_uv1 = a_texCoord1;
    #endif
    v_color = a_color;

    vec3 tagent = vec3(v_uv.x, 0.0, v_uv.y) * 2.0 - 1.0;    
    tagent = normalize(tagent);
    vec4 tw = vec4(-tagent.y, 0.0, tagent.x, 0.0);    
    v_tangent = normalize(vec3(tw.xyz));  

    CC_TRANSFER_FOG(pos);
    CC_TRANSFER_SHADOW(pos);

    return cc_matProj * (cc_matView * matWorld) * In.position;
  }

}%

CCProgram spectrum-fs %{
  precision highp float;
  #include <legacy/output>
  #include <legacy/fog-fs>
  #include "spectrum-lib"

  in vec2 v_uv;
  in vec3 v_position;
  in vec3 v_normal;
  in vec3 v_tangent;      
  in vec3 v_bitangent;
  in vec3 v_rgb;

  uniform sampler2D mainTexture;

  uniform Constant {
    vec4 mainColor;
    float dist;
    float roughness;
  };

  vec3 blend3(vec3 x){
    vec3 y = 1.0 - x * x;
    y = max(y, vec3(0.0, 0.0, 0.0));
    return y;
  }

  vec4 frag () {     

    vec3 N = normalize(v_normal);
    vec3 T = normalize(v_tangent);
    //vec3 T = normalize( vec3(v_uv.x, 0.0, sqrt(1.0 - v_uv.x*v_uv.x) ));
    vec3 V = normalize(cc_cameraPos.xyz - v_position);
    vec3 L = normalize(cc_mainLitDir.xyz);    
    vec3 H = L + V;   
 
    float cos_theta_v = dot(T, V);   
    float cos_theta_l = dot(T, L);   
    float u = abs(cos_theta_l - cos_theta_v);

    //float u = abs(dot(T, H));
    float w = dot(N, H);
    float e = roughness * u / w;

    float c = exp(-e*e);    
    vec3 anis = cc_mainLitColor.rgb * c;        
    if( u  < 0.0 ) u = -u;

    u *= dist;

    vec3 color = vec3(0.0);
    for(float n = 1.0; n <= 7.0; n ++ ){
      float w = u / n;
      color += spectral_zucconi6(w); 
    }
    color = clamp(color, 0.0, 1.0);            

    vec4 col = mainColor * texture(mainTexture, v_uv);
    col.rgb += color + anis;
    CC_APPLY_FOG(col, v_position);
    return CCFragOutput(col);
  }
}%